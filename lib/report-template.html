<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>%reportName% - kbn-alert-load report</title>
  <link rel="shortcut icon" href="https://elastic.co/favicon.ico" type="image/x-icon">
  <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-lite@4"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-embed@6"></script>
  <!--
  <script src="https://cdn.jsdelivr.net/npm/vega@5/build/vega.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-lite@4/build/vega-lite.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-embed@6/build/vega-embed.js"></script>
  -->
  
  <style>
    td {
      padding-top: 0;
      padding-bottom: 0;
    }
    h3, h4, table {
      margin: 0.5em 0;
    }
    .viz {
      width: 100%;
      padding: 1em 2em;
    }
    .indent {
      margin-left: 2em;
    }
  </style>
</head>

<body>
  <h1>%reportName% - kbn-alert-load report</h1>

  <table width="100%">
    <tr>
      <td valign="top">
        <h3>load test results for Kibana alerting</h3>
        <table>
          <tr><td>suite:</td><td id='var-description'></td></tr>
          <tr><td>date:</td><td>%date%</td></tr>
          <tr><td>zone:</td><td>%zone%</td></tr>
          <tr><td>suite id:</td><td id='var-suite'></td></tr>
        </table>
      </td>
      <td valign="top">
        <h3>common scenario settings</h3>
        <table id='table-shared-settings'></table>
      </td>
    </tr>
  </table>
  
  <!--
  <h3>scenario-specific settings</h3>
  <div class='indent'>
    <div id='table-scenario-settings'></div>
  </div>
  -->

  <div class="viz" id="vis-executions-per-minute"></div>
  <div class="viz" id="vis-execution-failures-per-minute"></div>
  <div class="viz" id="vis-execution-time"></div>
  <div class="viz" id="vis-time-between-alert-executions"></div>
  <div class="viz" id="vis-kb-status"></div>
  <div class="viz" id="vis-es-status"></div>
  <div class="viz" id="vis-kb-tm-stats"></div>
  <div class="viz" id="vis-kb-tm-runtime-stats"></div>
  <div class="viz" id="vis-kb-tm-schedule"></div>

  <p><i>generated by <a href='https://github.com/pmuellr/kbn-alert-load'>kbn-alert-load</a></i></p>
</body>

<script>
  'use strict'
  const { eventLog, kbStatus, KbTaskManager, esStatus, suite, deployments } = getAllData()
  const chartWidth = 200
  const colors = [
    '#00BFB3',
    '#F04E98',
    '#1BA9F5',
    '#0077CC',
  ]

  console.log(KbTaskManager)
  console.log(JSON.stringify(KbTaskManager))

  document.getElementById('var-suite').innerHTML = suite.id
  document.getElementById('var-description').innerHTML = suite.description
  document.getElementById('table-shared-settings').innerHTML = getSharedSettings()
  // document.getElementById('table-scenario-settings').innerHTML = getScenarioSetttings()

  const earliestDate = Date.parse(eventLog[0].date)

  // augment the eventLog
  eventLog.forEach(event => {
    event.dateNumber = Date.parse(event.date)
    event.dateRelative = event.dateNumber - earliestDate
    event.minute = event.dateRelative / 1000 / 60
  })

  // augment the kbStatus
  kbStatus.forEach(status => {
    status.dateNumber = Date.parse(status.metrics.last_updated)
    status.dateRelative = status.dateNumber - earliestDate
    status.minute = status.dateRelative / 1000 / 60
  })

  Object.keys(KbTaskManager)
    .forEach(scenario => {
      const earliestTMDateInScenario = Object.values(KbTaskManager[scenario]).map(stats => Date.parse(stats[0].timestamp)).sort()[0]
      // augment the KbTaskManager
      Object.keys(KbTaskManager[scenario]).forEach(tmId => {
        KbTaskManager[scenario][tmId].forEach(stats => {
          const pollInterval = stats.stats.configuration.value.poll_interval
          stats.dateNumber = Date.parse(stats.timestamp)
          stats.dateRelative = stats.dateNumber - earliestTMDateInScenario
          stats.minute = stats.dateRelative / 1000 / 60
        })
      })
    })

  // augment the esStatus
  esStatus.forEach(status => {
    status.dateNumber = Date.parse(status.date)
    status.dateRelative = status.dateNumber - earliestDate
    status.minute = status.dateRelative / 1000 / 60

    status.heapPercent = parseInt(status['heap.percent'], 10)
    status.ramPercent = parseInt(status['ram.percent'], 10)
    status.cpuPercent = parseInt(status.cpu, 10)
  })

  const lastExecutions = new Map()
  eventLog.forEach(event => {
    if (!event.alert) return

    const key = `${event.deployment}-${event.alert}`
    const lastExecution = lastExecutions.get(key)
    if (lastExecution) {
      event.lastInterval = (event.dateNumber - lastExecution) / 1000 / 60
    }
    lastExecutions.set(key, event.dateNumber)
  })

  vegaEmbed('#vis-execution-time', {
    $schema: 'https://vega.github.io/schema/vega-lite/v4.json',
    title: 'execution time',
    width: chartWidth,
    mark: { 
      type: 'point', 
      size: 100,
      strokeWidth: 1,
      opacity: 0.7,
      color: colors[0],
      tooltip: true
    },
    encoding: {
      x: {
        title: 'minutes since start',
        field: 'dateRelative',
        type: 'temporal',
        axis: {
          format: '%-M',
          formatType: 'time',
          tickCount: 'minute',
        }
      },
      y: {
        title: 'execution time (milliseconds)',
        field: 'duration',
        type: 'quantitative',
        scale: { zero: true, type: 'log' },
        axis: { grid: false }
      },
      column: {
        field: 'scenario',
        header: { title: null },
      }
    },
    data: { values: eventLog }
  })

  vegaEmbed('#vis-time-between-alert-executions', {
    $schema: 'https://vega.github.io/schema/vega-lite/v4.json',
    title: 'times between alert executions',
    width: chartWidth,
    mark: { 
      type: 'point', 
      shape: 'square',
      size: 100,
      strokeWidth: 1,
      opacity: 0.4,
      color: colors[1],
      tooltip: true
    },
    encoding: {
      x: {
        title: 'minutes since start',
        field: 'dateRelative',
        type: 'temporal',
        axis: {
          format: '%-M',
          formatType: 'time',
          tickCount: 'minute',
        }
      },
      y: {
        title: 'last execution (minutes)',
        field: 'lastInterval',
        type: 'quantitative',
        scale: { zero: true },
        axis: { grid: false }
      },
      column: {
        field: 'scenario',
        header: { title: null },
      }
    },
    data: { values: eventLog }
  })

  vegaEmbed('#vis-executions-per-minute', {
    $schema: 'https://vega.github.io/schema/vega-lite/v4.json',
    title: 'executions per minute',
    width: chartWidth,
    mark: { 
      type: 'bar', 
      tooltip: true, 
      cornerRadiusEnd: 4,
      color: colors[2],
    },
    encoding: {
      x: {
        bin: { step: 1 },
        field: 'minute',
        type: 'ordinal',
        title: 'minutes since start (binned)',
      },
      y: {
        title: 'executions',
        aggregate: 'count',
      },
      column: {
        field: 'scenario',
        header: { title: null },
      }
    },
    data: { values: eventLog }
  })

  vegaEmbed('#vis-execution-failures-per-minute', {
    $schema: 'https://vega.github.io/schema/vega-lite/v4.json',
    title: 'execution failures per minute',
    width: chartWidth,
    mark: { 
      type: 'bar', 
      tooltip: true, 
      cornerRadiusEnd: 4,
      color: colors[2],
    },
    encoding: {
      x: {
        bin: { step: 1 },
        field: 'minute',
        type: 'ordinal',
        title: 'minutes since start (binned)',
      },
      y: {
        title: 'executions',
        aggregate: 'count',
      },
      column: {
        field: 'deployment',
        header: { title: null },
      }
    },
    data: { values: eventLog.filter(log => log.outcome === 'failure') }
  })

  vegaEmbed('#vis-kb-status', {
    $schema: 'https://vega.github.io/schema/vega-lite/v4.json',
    title: 'kibana metrics',
    data: { values: kbStatus },
    hconcat: [
      metricSpec('load avg (1m)', 'metrics.os.load.1m'),
      metricSpec('event loop delay', 'metrics.process.event_loop_delay'),
      metricSpec('rss', 'metrics.process.memory.resident_set_size_in_bytes'),
    ]
  })

  const flattenedTMStats = Object.entries(KbTaskManager)
    .reduce((scenarios, [scenario, stats]) => {
      // flaten all TM stats under their scenario
      scenarios[scenario] = Object.values(stats).reduce((all, tm) => [...all, ...tm], [])
      return scenarios
    },{})

  vegaEmbed('#vis-kb-tm-stats', {
    $schema: 'https://vega.github.io/schema/vega-lite/v4.json',
    title: 'kibana Task Manager metrics',
    datasets: flattenedTMStats,
    hconcat: [
      ...Object.keys(flattenedTMStats)
        .map(scenario => tmMetricSpec(`Drift (p50) ${scenario}`, 'stats.runtime.value.drift.p50', scenario)),
      ...Object.keys(flattenedTMStats)
        .map(scenario => tmMetricSpec(`Drift (p90) ${scenario}`, 'stats.runtime.value.drift.p90', scenario)),
      ...Object.keys(flattenedTMStats)
        .map(scenario => tmMetricSpec(`Alert Task Duration (p50) ${scenario}`, 'stats.runtime.value.duration.p50', scenario)),
      ...Object.keys(flattenedTMStats)
        .map(scenario => tmMetricSpec(`Alert Task Duration (p90) ${scenario}`, 'stats.runtime.value.duration.p90', scenario))
    ]
  })
   
  const normaliseRuntimeResults = Object.entries(flattenedTMStats)
    .reduce((scenarios, [scenario, stats]) => {
      scenarios[scenario] = stats.reduce((allRuntimeStats, tmStats) => {
        const { id } = tmStats
        const { result = {}, polling = {} } = tmStats.stats.runtime.value
        if(result.Success + result.RetryScheduled + result.Failed > 0){
          allRuntimeStats.push({ id, stat:'result', category: 'Success', percentage: result.Success })
          allRuntimeStats.push({ id, stat:'result', category: 'RetryScheduled', percentage: result.RetryScheduled })
          allRuntimeStats.push({ id, stat:'result', category: 'Failed', percentage: result.Failed })
        }
        if(polling.NoTasksClaimed + polling.RanOutOfCapacity + polling.PoolFilled > 0){
          allRuntimeStats.push({ id, stat:'polling', category: 'NoTasksClaimed', percentage: polling.NoTasksClaimed })
          allRuntimeStats.push({ id, stat:'polling', category: 'RanOutOfCapacity', percentage: polling.RanOutOfCapacity })
          allRuntimeStats.push({ id, stat:'polling', category: 'PoolFilled', percentage: polling.PoolFilled })
        }        
        return allRuntimeStats
      }, [])
      return scenarios
    },{})

  console.log(normaliseRuntimeResults)

  vegaEmbed('#vis-kb-tm-runtime-stats', {
    $schema: 'https://vega.github.io/schema/vega-lite/v4.json',
    title: 'kibana Task Manager Runtime Results',
    datasets: normaliseRuntimeResults,
    hconcat: [
      ...Object.keys(normaliseRuntimeResults)
        .map(scenario => tmPieMetricSpec(`Task Run Results ${scenario}`, 'result', scenario)),
      ...Object.keys(normaliseRuntimeResults)
        .map(scenario => tmPieMetricSpec(`Task Polling Results ${scenario}`, 'polling', scenario))
    ]
  })

  // reduce to one TM for schedule density 
  const flattenedTMScheduleDensity = Object.entries(KbTaskManager)
    .reduce((scenarios, [scenario, stats]) => {
      // choose one TM and reduce to its schedule density stat
      const allTaskManagers = Object.values(stats);
      const randomTaskManager = allTaskManagers[0];
      const earliestTMScheduleDensityInScenario = Date.parse(randomTaskManager[0].stats.workload.timestamp)

      const measuredTimestamps = new Set()

      scenarios[scenario] = randomTaskManager.reduce((allDensities, stat, statCycle) => {
        //skip duplicate measurments
        if(measuredTimestamps.has(stat.stats.workload.timestamp)){
          return allDensities
        }
        measuredTimestamps.add(stat.stats.workload.timestamp)

        const pollInterval = stat.stats.configuration.value.poll_interval
        const taskManagmentStatsTakenAt = Date.parse(stat.stats.workload.timestamp)
        // rounmd measuredAt relative to the previous TM measurments so that they all fall in the same bucket
        const measuredAt = taskManagmentStatsTakenAt -
          ((taskManagmentStatsTakenAt - earliestTMScheduleDensityInScenario) % pollInterval)

        allDensities.push(
          ...stat.stats.workload.value.estimated_schedule_density
            .map((scheduled, cycle) => ({
              scheduled,
              availableWorkers: stat.stats.configuration.value.max_workers * allTaskManagers.length,
              scheduledAt: measuredAt + cycle * pollInterval,
              measuredAt
            }))
        )
        return allDensities
      }, [])
      return scenarios
    }, {})

  console.log(flattenedTMScheduleDensity)

  vegaEmbed('#vis-kb-tm-schedule', {
    $schema: 'https://vega.github.io/schema/vega-lite/v4.json',
    title: 'kibana Task Manager Schedule Density',
    datasets: flattenedTMScheduleDensity,
    width: "container",
    hconcat: Object.entries(flattenedTMScheduleDensity)
      .map(([scenario, tmScheduleDensity]) => ({
      title: `Schedule Density ${scenario}`,
      data: { name: scenario },
      mark: "rect",
      encoding: {
        x: {
          field: "scheduledAt",
          title: "Scheduled At",
          // "timeUnit": {
          //   "unit": "milliseconds",
          //   "step": 3000
          // }
        },
        y: {
          field: "measuredAt",
          title: "Measured At"
        },
        color: {
          field: "scheduled",
          condition: {
            "test": `datum['scheduled'] > datum['availableWorkers']`,
            "value": "red"
          },
          type: "quantitative",
        }
      }
    }))
  })

  vegaEmbed('#vis-es-status', {
    $schema: 'https://vega.github.io/schema/vega-lite/v4.json',
    title: 'elasticsearch metrics',
    data: { values: esStatus },
    hconcat: [
      metricSpec('heap %', 'heapPercent'),
      metricSpec('ram %', 'ramPercent'),
      metricSpec('cpu', 'cpuPercent'),
    ]
  })

  function metricSpec(title, field) {
    return {
      title,
      width: chartWidth,
      mark: { 
        type: 'line', 
        opacity: 0.6,
        tooltip: true
      },
      encoding: {
        x: {
          title: 'minutes since start',
          field: 'dateRelative',
          type: 'temporal',
          axis: {
            format: '%-M',
            formatType: 'time',
            tickCount: 'minute',
          }
        },
        y: {
          title: null,
          field,
          type: 'quantitative',
          scale: { zero: true },
          axis: { grid: false }
        },
        color: {
          field: 'scenario',
          scheme: 'set1',
        },
      },
    }
  }

  function tmMetricSpec(title, field, data) {
    return {
      title,
      data: { name: data },
      width: chartWidth,
      mark: { 
        type: 'line', 
        opacity: 0.6,
        tooltip: true
      },
      encoding: {
        x: {
          "title": "minutes since start",
          "field": "dateRelative",
          "type": "temporal",
          "axis": {
            "format": "%-M",
            "formatType": "time",
            "tickCount": "minute"
          }
        },
        y: {
          field,
          "type": "quantitative"
        },
        color: {
          "field": "id",
          "type": "nominal"
        }
      }
    }
  }

  function tmPieMetricSpec(title, field, data) {
    return {
      title,
      data: { name: data },
      width: chartWidth,
      mark: "bar",
      transform: [
        {
          filter: { "field": "stat", "equal": field }
        },
        {
          "groupby": [`id`],
          "joinaggregate": [
            {
              "op": "sum",
              "field": `percentage`,
              "as": "totalResults"
            }
          ]
        },
        {
          "calculate": `datum.percentage/datum.totalResults * 100`,
          "as": "percentOfTotal"
        }
      ],
      encoding: {
        x: {
          field: `percentOfTotal`,
          type: "quantitative",
          title: "% of all Results"
        },
        y: {
          "field": `id`
        },
        color: {
          "field": `category`
        }
      },
      resolve: {
        scale: {
          color: "independent"
        },
        legend: {
          color: "independent"
        }
      }
    }
  }

  function getSharedSettings() {
    const { sameVals } = getScenarioSameAndDiffProps()

    const result = []
    for (const key of Array.from(sameVals.keys()).sort()) {
      result.push(`<tr><td>${key}:</td><td align="right">${sameVals.get(key)}</td></tr`)
    }

    return result.join('\n')
  }

  function getScenarioSetttings() {
    const { sameVals, diffVals } = getScenarioSameAndDiffProps()

    const result = []
    for (const deployment of deployments) {
      result.push(`<h4>${deployment.scenario.sortName}</h4>`)
      result.push('<div class="indent">')
      result.push(`<table>`)
      for (const key of Array.from(diffVals.keys()).sort()) {
        result.push(`<tr><td>${key}:</td><td align="right">${deployment.scenario[key]}</td></tr>`)
      }
      result.push('</table>')
      result.push('</div>')
    }

    return result.join('\n')
  }

  function getScenarioPropsAndNames() {
    /** @type { Set<string> } */
    const allProps = new Set()
    /** @type { string[] } */
    const names = []
    for (const deployment of deployments) {
      const scenario = deployment.scenario
      for (const key of Object.keys(scenario)) {
        if (key === 'name') {
          names.push(scenario.name)
        } else if (key !== 'sortName') {
          allProps.add(key)
        }
      }
    }

    return {
      names,
      props: Array.from(allProps.values()).sort()
    }
  }

  function getScenarioSameAndDiffProps() {
    const { props } = getScenarioPropsAndNames()

    /** @type { Map<string, any> } */
    const sameVals = new Map()
    /** @type { Set<string> } */
    const diffVals = new Set()

    for (const deployment of deployments) {
      const scenario = deployment.scenario
      for (const prop of props) {
        if (!sameVals.has(prop)) {
          sameVals.set(prop, scenario[prop])
        } else {
          if (sameVals.get(prop) !== scenario[prop]) {
            diffVals.add(prop)
          }
        }
      }
    }

    for (const diffValKey of diffVals) {
      sameVals.delete(diffValKey)
    }

    return {
      sameVals,
      diffVals,
    }
  }

  function getAllData() {
    const data = 
    // data-start
    {
      /** @type { any } */
      suite: "%Suite%",
      /** @type { any[] } */
      deployments: ["%Deployments%"],
      /** @type { any[] } */
      eventLog: ["%EventLog%"],
      /** @type { any[] } */
      kbStatus: ["%KbStatus%"],
      /** @type { Record<string, any[]> } */
      KbTaskManager: ["%KbTaskManager%"],
      /** @type { any[] } */
      esStatus: ["%EsStatus%"],
    }
    // data-end

    return data
  }
</script>

</html>
